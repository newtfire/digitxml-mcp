#!.venv/bin/python3.12
"""
Source: MCP Server code generated by Claude Sonnet prompted by ebeshero on 6 January 2026.
MCP Server for XML Manipulation with Saxon XPath 3.1/XQuery 3.1/XSLT 3.0
Uses Saxon-HE (Home Edition) via saxonche for advanced XML processing
"""

import json
from typing import Any, Optional
from pathlib import Path
from datetime import datetime
import saxonche
from saxonche import PySaxonProcessor, PyXPathProcessor, PyXQueryProcessor, PyXslt30Processor


# This would typically use the MCP SDK: from mcp.server import Server
# For illustration, showing the conceptual structure

class SaxonXMLMCPServer:
    """MCP Server for XML operations with Saxon XPath 3.1/XQuery/XSLT 3.0 support"""

    def __init__(self, xml_path: str, schema_path: str = None, backup_dir: str = "./backups"):
        self.xml_path = Path(xml_path)
        self.schema_path = Path(schema_path) if schema_path else None
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(exist_ok=True)

        # Initialize Saxon processor
        self.saxon_proc = PySaxonProcessor(license=False)  # HE version

        # Load XML document
        with open(self.xml_path, 'r', encoding='utf-8') as f:
            xml_text = f.read()
        self.xml_node = self.saxon_proc.parse_xml(xml_text=xml_text)

        # Initialize specialized processors
        self.xpath_proc = self.saxon_proc.new_xpath_processor()
        self.xquery_proc = self.saxon_proc.new_xquery_processor()
        self.xslt_proc = self.saxon_proc.new_xslt30_processor()

        # Set context for XPath
        self.xpath_proc.set_context(xdm_item=self.xml_node)

        # Schema support
        self.schema_validator = None
        if self.schema_path and self.schema_path.exists():
            self.schema_validator = self.saxon_proc.new_schema_validator()
            self.schema_validator.register_schema(xsd_file=str(self.schema_path))

    def create_backup(self) -> str:
        """Create a timestamped backup of the current XML"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = self.backup_dir / f"backup_{timestamp}.xml"

        # Serialize current document
        serializer = self.saxon_proc.new_serializer()
        serializer.set_output_file(str(backup_path))
        serializer.serialize_xdm_value(self.xml_node)

        return str(backup_path)

    def reload_document(self):
        """Reload XML document from file"""
        with open(self.xml_path, 'r', encoding='utf-8') as f:
            xml_text = f.read()
        self.xml_node = self.saxon_proc.parse_xml(xml_text=xml_text)
        self.xpath_proc.set_context(xdm_item=self.xml_node)

    def save_document(self):
        """Save current document to file"""
        serializer = self.saxon_proc.new_serializer()
        serializer.set_output_file(str(self.xml_path))
        serializer.serialize_xdm_value(self.xml_node)

    # ===== READ TOOLS =====

    def xpath_query(self, xpath: str, version: str = "3.1", return_count: bool = False) -> dict:
        """
        Execute XPath query using Saxon (supports XPath 3.1)

        Tool: xpath_query
        Args:
            xpath: XPath expression to evaluate (can use 3.1 features)
            version: XPath version ("3.1", "3.0", "2.0")
            return_count: If true, only return count of matches
        Returns:
            Dictionary with results or count
        """
        try:
            # Create new XPath processor for this query
            xpath_proc = self.saxon_proc.new_xpath_processor()
            xpath_proc.set_context(xdm_item=self.xml_node)

            # Compile and evaluate
            xpath_executable = xpath_proc.compile(xpath)
            result = xpath_executable.evaluate()

            if return_count:
                count = result.size if hasattr(result, 'size') else len(list(result))
                return {
                    "success": True,
                    "count": count,
                    "xpath": xpath,
                    "version": version
                }

            # Convert results to serializable format
            serialized = []
            if result is not None:
                # Handle different result types
                if hasattr(result, '__iter__'):
                    for item in result:
                        serialized.append(self._serialize_xdm_item(item))
                else:
                    serialized.append(self._serialize_xdm_item(result))

            return {
                "success": True,
                "count": len(serialized),
                "results": serialized,
                "xpath": xpath,
                "version": version
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "xpath": xpath
            }

    def xquery_query(self, xquery: str, external_vars: dict = None) -> dict:
        """
        Execute XQuery 3.1 query using Saxon

        Tool: xquery_query
        Args:
            xquery: XQuery expression to evaluate
            external_vars: Optional external variables as key-value pairs
        Returns:
            Dictionary with results
        """
        try:
            xquery_proc = self.saxon_proc.new_xquery_processor()

            # Set external variables if provided
            if external_vars:
                for var_name, var_value in external_vars.items():
                    xquery_proc.set_parameter(var_name, self.saxon_proc.make_string_value(str(var_value)))

            # Set context item
            xquery_proc.set_context(xdm_item=self.xml_node)

            # Execute query
            result = xquery_proc.run_query_to_value(query_text=xquery)

            # Serialize results
            serialized = []
            if result is not None:
                if hasattr(result, '__iter__'):
                    for item in result:
                        serialized.append(self._serialize_xdm_item(item))
                else:
                    serialized.append(self._serialize_xdm_item(result))

            return {
                "success": True,
                "count": len(serialized),
                "results": serialized,
                "xquery": xquery[:100] + "..." if len(xquery) > 100 else xquery
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "xquery": xquery[:100] + "..." if len(xquery) > 100 else xquery
            }

    def xslt_transform(self, xslt: str, params: dict = None, save_output: str = None) -> dict:
        """
        Apply XSLT 3.0 transformation using Saxon

        Tool: xslt_transform
        Args:
            xslt: XSLT stylesheet as string
            params: Optional stylesheet parameters
            save_output: Optional file path to save transformed output
        Returns:
            Dictionary with transformation result
        """
        try:
            xslt_proc = self.saxon_proc.new_xslt30_processor()

            # Compile stylesheet
            executable = xslt_proc.compile_stylesheet(stylesheet_text=xslt)

            # Set parameters if provided
            if params:
                for param_name, param_value in params.items():
                    executable.set_parameter(param_name, self.saxon_proc.make_string_value(str(param_value)))

            # Transform
            result = executable.transform_to_string(xdm_node=self.xml_node)

            # Save if requested
            if save_output:
                output_path = Path(save_output)
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(result)

            return {
                "success": True,
                "result": result,
                "saved_to": save_output if save_output else None
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def get_structure_summary(self, max_depth: int = 3) -> dict:
        """
        Get a summary of the XML structure using XPath 3.1

        Tool: get_structure_summary
        Args:
            max_depth: Maximum depth to traverse
        Returns:
            Dictionary describing XML structure
        """
        try:
            # Use XPath 3.1 features to analyze structure
            queries = {
                "root_name": "name(/*)",
                "namespaces": "in-scope-prefixes(/*)",
                "element_names": "distinct-values(//*[not(*)]!name())",
                "elements_with_children": "distinct-values(//*[*]!name())",
                "attribute_names": "distinct-values(//@*/name())"
            }

            structure = {}
            for key, query in queries.items():
                result = self.xpath_query(query)
                if result["success"]:
                    structure[key] = result["results"]

            return {
                "success": True,
                "structure": structure,
                "xpath_version": "3.1"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def validate_xpath(self, xpath: str, version: str = "3.1") -> dict:
        """
        Validate XPath syntax without executing

        Tool: validate_xpath
        Args:
            xpath: XPath expression to validate
            version: XPath version to validate against
        Returns:
            Dictionary indicating if xpath is valid
        """
        try:
            xpath_proc = self.saxon_proc.new_xpath_processor()
            xpath_proc.compile(xpath)
            return {
                "success": True,
                "valid": True,
                "xpath": xpath,
                "version": version
            }
        except Exception as e:
            return {
                "success": True,
                "valid": False,
                "error": str(e),
                "xpath": xpath
            }

    def find_irregularities(self, checks: list[dict]) -> dict:
        """
        Run multiple XPath 3.1 validation checks to find irregularities

        Tool: find_irregularities
        Args:
            checks: List of check definitions with xpath and description
        Returns:
            Dictionary with all irregularities found
        """
        irregularities = []

        for check in checks:
            xpath = check.get("xpath")
            description = check.get("description", "Unnamed check")
            check_type = check.get("type", "xpath")  # xpath or xquery

            if check_type == "xquery":
                result = self.xquery_query(xpath)
            else:
                result = self.xpath_query(xpath)

            if result["success"] and result["count"] > 0:
                irregularities.append({
                    "description": description,
                    "query": xpath,
                    "type": check_type,
                    "count": result["count"],
                    "samples": result["results"][:5]  # First 5 samples
                })

        return {
            "success": True,
            "total_issues": len(irregularities),
            "irregularities": irregularities
        }

    # ===== WRITE TOOLS (Using XSLT for transformations) =====

    def apply_transformation(self, xslt: str, validate: bool = True,
                             description: str = "Custom transformation") -> dict:
        """
        Apply XSLT 3.0 transformation to modify document

        Tool: apply_transformation
        Args:
            xslt: XSLT stylesheet to apply
            validate: Whether to validate against schema
            description: Description of transformation for audit
        Returns:
            Dictionary with operation result
        """
        try:
            backup_path = self.create_backup()

            # Apply transformation
            result = self.xslt_transform(xslt)

            if not result["success"]:
                return result

            # Parse transformed result
            self.xml_node = self.saxon_proc.parse_xml(xml_text=result["result"])
            self.xpath_proc.set_context(xdm_item=self.xml_node)

            # Validate if requested
            if validate and self.schema_validator:
                validation_result = self._validate_document()
                if not validation_result["valid"]:
                    # Rollback
                    self.reload_document()
                    return {
                        "success": False,
                        "error": "Schema validation failed",
                        "validation_errors": validation_result["errors"]
                    }

            # Save changes
            self.save_document()

            return {
                "success": True,
                "description": description,
                "backup_path": backup_path
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def batch_corrections(self, corrections: list[dict], validate: bool = True) -> dict:
        """
        Apply multiple corrections using XSLT transformation

        Tool: batch_corrections
        Args:
            corrections: List of correction operations (generates XSLT internally)
            validate: Whether to validate against schema
        Returns:
            Dictionary with operation result
        """
        try:
            backup_path = self.create_backup()

            # Build XSLT from corrections
            xslt = self._generate_correction_xslt(corrections)

            # Apply transformation
            result = self.apply_transformation(xslt, validate,
                                               description=f"Batch corrections ({len(corrections)} operations)")

            if result["success"]:
                result["corrections_applied"] = len(corrections)
                result["backup_path"] = backup_path

            return result

        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    # ===== HELPER METHODS =====

    def _serialize_xdm_item(self, item) -> dict:
        """Convert XDM item to serializable format"""
        try:
            if hasattr(item, 'string_value'):
                value = item.string_value
            else:
                value = str(item)

            item_type = type(item).__name__

            # Try to get node info if it's an element
            result = {
                "value": value,
                "type": item_type
            }

            if hasattr(item, 'node_name'):
                result["node_name"] = item.node_name

            return result
        except:
            return {"value": str(item), "type": "unknown"}

    def _validate_document(self) -> dict:
        """Validate current document against schema"""
        if not self.schema_validator:
            return {"valid": True, "message": "No schema configured"}

        try:
            self.schema_validator.validate(xdm_node=self.xml_node)
            return {"valid": True}
        except Exception as e:
            return {
                "valid": False,
                "errors": [str(e)]
            }

    def _generate_correction_xslt(self, corrections: list[dict]) -> str:
        """Generate XSLT 3.0 stylesheet from correction operations"""
        templates = []

        for i, correction in enumerate(corrections):
            op = correction.get("operation")

            if op == "update":
                xpath = correction["xpath"]
                updates = correction["updates"]

                # Generate template for update
                template = f"""
    <xsl:template match="{xpath}" priority="{i + 10}">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
"""
                if "attributes" in updates:
                    for attr, value in updates["attributes"].items():
                        template += f'            <xsl:attribute name="{attr}">{value}</xsl:attribute>\n'

                if "text" in updates:
                    template += f'            <xsl:text>{updates["text"]}</xsl:text>\n'
                else:
                    template += '            <xsl:apply-templates select="node()"/>\n'

                template += """        </xsl:copy>
    </xsl:template>
"""
                templates.append(template)

            elif op == "delete":
                xpath = correction["xpath"]
                templates.append(f'    <xsl:template match="{xpath}"/>\n')

        # Build complete stylesheet
        xslt = f"""<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="3.0" 
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
     <xsl:mode on-no-match="shallow copy"/>
    <!-- Identity template 
    <xsl:template match="@*|node()">
        <xsl:copy>
            <xsl:apply-templates select="@*|node()"/>
        </xsl:copy>
    </xsl:template> -->

    <!-- Correction templates -->
{''.join(templates)}
</xsl:stylesheet>
"""
        return xslt


# Example MCP server configuration
def create_mcp_server_config():
    """
    MCP server configuration for Saxon-based XML processing
    """
    return {
        "name": "saxon-xml-server",
        "version": "1.0.0",
        "description": "MCP server for XML manipulation with Saxon XPath 3.1/XQuery 3.1/XSLT 3.0",
        "capabilities": {
            "xpath_version": "3.1",
            "xquery_version": "3.1",
            "xslt_version": "3.0",
            "schema_validation": True
        },
        "tools": [
            {
                "name": "xpath_query",
                "description": "Execute XPath 3.1 query with advanced features (maps, arrays, higher-order functions)",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "xpath": {
                            "type": "string",
                            "description": "XPath 3.1 expression (supports => operator, arrow functions, etc.)"
                        },
                        "version": {
                            "type": "string",
                            "enum": ["3.1", "3.0", "2.0"],
                            "default": "3.1"
                        },
                        "return_count": {"type": "boolean", "default": False}
                    },
                    "required": ["xpath"]
                }
            },
            {
                "name": "xquery_query",
                "description": "Execute XQuery 3.1 query for complex data extraction and transformation",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "xquery": {
                            "type": "string",
                            "description": "XQuery 3.1 expression"
                        },
                        "external_vars": {
                            "type": "object",
                            "description": "External variables to pass to query"
                        }
                    },
                    "required": ["xquery"]
                }
            },
            {
                "name": "xslt_transform",
                "description": "Apply XSLT 3.0 transformation (supports streaming, try/catch, packages)",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "xslt": {"type": "string"},
                        "params": {"type": "object"},
                        "save_output": {"type": "string"}
                    },
                    "required": ["xslt"]
                }
            },
            {
                "name": "get_structure_summary",
                "description": "Analyze XML structure using XPath 3.1",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "max_depth": {"type": "integer", "default": 3}
                    }
                }
            },
            {
                "name": "find_irregularities",
                "description": "Run XPath 3.1 or XQuery validation checks",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "checks": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "xpath": {"type": "string"},
                                    "description": {"type": "string"},
                                    "type": {
                                        "type": "string",
                                        "enum": ["xpath", "xquery"],
                                        "default": "xpath"
                                    }
                                }
                            }
                        }
                    },
                    "required": ["checks"]
                }
            },
            {
                "name": "apply_transformation",
                "description": "Apply XSLT 3.0 transformation to modify document",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "xslt": {"type": "string"},
                        "validate": {"type": "boolean", "default": True},
                        "description": {"type": "string"}
                    },
                    "required": ["xslt"]
                }
            },
            {
                "name": "batch_corrections",
                "description": "Apply multiple corrections via generated XSLT",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "corrections": {"type": "array"},
                        "validate": {"type": "boolean", "default": True}
                    },
                    "required": ["corrections"]
                }
            }
        ]
    }


if __name__ == "__main__":
    # Example usage
    server = SaxonXMLMCPServer(
        xml_path="./data/catalog.xml",
        schema_path="./schemas/catalog.xsd",
        backup_dir="./backups"
    )

    # Example: Use XPath 3.1 features
    result = server.xpath_query(
        "//product[price < 50] => sort((), function($p) { $p/name })"
    )
    print(json.dumps(result, indent=2))

    # Example: Use XQuery for complex analysis
    xquery_result = server.xquery_query("""
        for $category in distinct-values(//product/category)
        return map {
            'category': $category,
            'count': count(//product[category = $category]),
            'avg_price': avg(//product[category = $category]/price)
        }
    """)
    print(json.dumps(xquery_result, indent=2))